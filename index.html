<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>♠️♣️CARDS♥️♦️</title>
</head>
    X:<input type="text" id="x">  Y:<input type="text" id="y"> <br>
    mX:<input type="text" id="mx">  mY:<input type="text" id="my"> <br>
    <button type="button" onmousedown="popCardFromDeck()">Hit</button>
    <div id="game" style="user-select: NONE;">
            <div class="outer-card draggable prototype" lock="false">
                <div class="inner-card flippable">
                    <div class="front-face">
                        <span class="number top">A</span>
                        <span class="suit top"></span>
                        <span class="card-display">
                            <span class="column left"></span>
                            <span class="column MIDDLE"></span>
                            <span class="column right"></span>
                        </span><!--end card-display-->
                        <span class="suit bot"></span>
                        <span class="number bot">A</span>
                    </div><!--end front-face-->
                    <div class="back-face">
                        <span class="card-back-display">CARD</span>
                    </div><!--end back-face-->
                </div><!--end inner-card-->
            </div><!--end outer-card-->
        <div class="hand slot" capacity=-1 lock=false id="player-hand">
            <div class="slot-start draggable" lock="true" style=
                "width: 250px;
                height: 350px;
                margin-right: 0px;
                outline: green solid 2px;
                visibility: visible;
                display: inline-block;
                "> <!--for inserting left most card-->
            </div>
        </div>
    </div><!--end #game-->
<script type="text/javascript">
    var game = document.getElementById('game');
    const protoSuit = document.createElement('span');
    protoSuit.classList.add('suit');
    const protoCard = game.querySelector('.outer-card'); //GET THE PROTOTYPE ELEMENT
    const cardData = {
        numbers : ['A','2','3','4','5','6','7','8','9','10','J','Q','K'],
        suits : ['♠️','♣️','♥️','♦️'],
        get randomNumber(){return getRandomFromArr(this.numbers);},
        get randomSuit(){return getRandomFromArr(this.suits);},
    };
    function Card(suit, number){this.suit = suit; this.number = number;}
    function createCard(number = cardData.randomNumber, suit = cardData.randomSuit){
        let clone = protoCard.cloneNode(true);
        clone.classList.remove('prototype');
        clone._number_ = number;
        clone._suit_ = suit;
        clone._cardDisplay_= clone.querySelector('.card-display');
        clone._cardCanvases_=clone.querySelectorAll('.card-canvas'); //FLIP USING CSS
        let leftCol = clone._cardDisplay_.querySelector('.column.left');
        let midCol = clone._cardDisplay_.querySelector('.column.MIDDLE');
        let rightCol = clone._cardDisplay_.querySelector('.column.right');
        //CREATE SUIT OBJECT BASE ON NUMBERS HERE
        let appendSuits=(l,m,r)=>{//ADD SUIT TO COLUMNS
            for(let i=0; i<l; i++){leftCol.appendChild(protoSuit.cloneNode());}
            for(let i=0; i<m; i++){midCol.appendChild(protoSuit.cloneNode());}
            for(let i=0; i<r; i++){rightCol.appendChild(protoSuit.cloneNode());}
            rotateBotSuits();
        }
        let rotateBotSuits=()=>{
            [leftCol, midCol, rightCol].forEach(innerArr=>{
                let botHalfCount = Math.floor(innerArr.children.length/2);
                let slicePos = innerArr.children.length - botHalfCount;
                let botHalf = [...innerArr.children].slice(slicePos);
                [...botHalf].forEach(suit=>{suit.style.transform = 'rotate(180deg)'});
            });
        }
        let hideSuit=(col, index)=>{
            col.children[index].style.visibility ='hidden';
        }
        switch (clone._number_){
            case 'A':appendSuits(0,1,0);break;
            case '2':appendSuits(0,2,0);break;
            case '3':appendSuits(0,3,0);break;
            case '4':appendSuits(2,0,2);break;
            case '5':appendSuits(2,1,2);break;
            case '6':appendSuits(3,0,3);break;
            case '7':appendSuits(3,2,3); hideSuit(midCol, 1); break;
            case '8':appendSuits(3,2,3);break;
            case '9':appendSuits(4,1,4);break;
            case '10':appendSuits(4,2,4);break;
            case 'J': case 'Q': case 'K':
                appendSuits(2,0,2);
                hideSuit(leftCol, 1);
                hideSuit(rightCol, 0);
                break;
        }
        [...clone.querySelectorAll('.number')].forEach(element=>{element.innerHTML = number;});
        [...clone.querySelectorAll('.suit')].forEach(element=>{element.innerHTML = suit;});
        clone.style.color = ['♥️','♦️'].includes(clone._suit_) ? 'crimson' : 'black';
        return clone;
    }
    function popCardFromDeck(){//TEST
        //testing for now
       let newCard = createCard();
       game.appendChild(newCard);
       newCard.style.left = '1400px';
       newCard.style.top = '0px';
       newCard.style.position='fixed';
       newCard.style.transition='left 1s, top 1s, margin 1s';

       //GETTING OFFSET HERE
       var hand = document.getElementById('player-hand');
       var lastChildRect = [...hand.children].pop().getBoundingClientRect();

       //TARGET
       var xOffset = lastChildRect.right - 200; //MAGIC NUMBER FROM CSS
       var yOffset = lastChildRect.top;

       //GO TO TARGET AFTER TIMEOUT
       setTimeout(()=>{
        newCard.style.left = `${xOffset}px`;
        newCard.style.top = `${yOffset}px`;
       },1);

      //use transistion end instead
      //APPEND and reset values
        setTimeout(()=>{
            console.log('frame called');
            hand.appendChild(newCard)
            newCard.style.left = `${0}px`;
            newCard.style.top = `${0}px`;
            newCard.style.position='relative';
        },1000);
    }
    //WHEN PAGE FINISH LOADING //PROBABLY WANT TO USE DEFERED ON THE SCRIPT INSTEAD
    window.onload = function(){
       for(let i =0; i<5; i++){
             let hand = game.querySelector('.hand');//TEST
             hand.appendChild(createCard()); //TEST
            //game.appendChild(createCard());
       }
        //game.appendChild(createCard());
       getDraggables();
       getSlots();
    };
    //
    //CARD DRAGGABLE LOGIC
    //
    //TODO: CLEAN UP CODE
    //startRightSibling and hoverRightSibling can be one
    //repitition in end transition
    //fix bug where startRightSibling margin is called when appending to right most
    //use enum state
    var draggables = [];
    function getDraggables(){//TODO RENAME, AND SPLIT SETTING LOGIC
        draggables = document.querySelectorAll('.draggable');
        [...draggables].forEach(element=>{element.addEventListener('mousedown', startDrag)});
        function startDrag(startEvent){ //MOUSE DOWN EVENT
            const DRAG_TARGET = startEvent.target.closest('.draggable');
            if(DRAG_TARGET.getAttribute('lock') === "true") return; //IF LOCKED RETURN
            if(game.getAttribute('transitioning') === "true") return; //OPTIONAL

            let _startSlot = startEvent.target.closest('.slot');
            if(!_startSlot) return; //THIS ALSO PREVENT SPAM CLICK

            //let dragStartTargetRightSibling = getNeighborElementsInParent(DRAG_TARGET, _startSlot).rightNextdoor;
            

            ///////////////////////////////////////////////////////////
            //set game attribute, remove dragging class, set transition
            game.setAttribute('drag-active', true);
            DRAG_TARGET.classList.add('dragging');
            DRAG_TARGET.style.transition = 'left 0s, top 0s, margin 1s';
            ///////////////////////////////////////////////////////////

            const DRAG_START = {//remember origin, child index
                MOUSE_POS: {x: startEvent.pageX, y: startEvent.pageY},
                POS: {x: DRAG_TARGET.getBoundingClientRect().x, y: DRAG_TARGET.getBoundingClientRect().y},
                INDEX: [..._startSlot.children].indexOf(DRAG_TARGET),
                SLOT: _startSlot,
                startRightSibling: getNeighborElementsInParent(DRAG_TARGET, _startSlot).rightNextdoor
            };
            //BREAKS TRANSITION , SINCE THEY ARE GETTING BOUNDING BOX IN MID TRANSITION
            // if(DRAG_START.startRightSibling){ 
            //     DRAG_START.startRightSibling.style.transition = 'left 0s, top 0s, margin 0s';
            //     DRAG_START.startRightSibling.style.marginLeft = '50px';
            //     //RESET ON RELEASE
            // }
            DRAG_TARGET.style.marginLeft = '0px';
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', releaseDrag);
            DRAG_TARGET.style.position = 'fixed';
            game.appendChild(DRAG_TARGET);
            requestAnimationFrame(()=>{onDrag(startEvent)});
            function onDrag(event){
                let _mousePosDelta = {
                    x: event.pageX - DRAG_START.MOUSE_POS.x, 
                    y: event.pageY - DRAG_START.MOUSE_POS.y
                }
                let followPos = {
                    x: DRAG_START.POS.x + _mousePosDelta.x,
                    y: DRAG_START.POS.y + _mousePosDelta.y
                };
                //follow mouse
                DRAG_TARGET.style.left = `${followPos.x}px`;
                DRAG_TARGET.style.top = `${followPos.y}px`;
                
                //OPTIONAL, BLOCKS GAME TO BE ABLE TO START ANOTHER TRANSITION, USE IF BUGGY
                if(followPos.x!==DRAG_START.POS.x||followPos.y!==DRAG_START.POS.y)
                    game.setAttribute('transitioning', true);
                else {game.setAttribute('transitioning', false);}
            } 
            function releaseDrag(releaseEvent){
                const RELEASE_STATE = {LEFT_MOST: 0, MIDDLE: 1, RIGHT_MOST: 2, NONE: 3};

                //BREAKS TRANSITION , SINCE THEY ARE GETTING BOUNDING BOX IN MID TRANSITION
                // DRAG_START.startRightSibling.style.transition = 'left 0s, top 0s, margin 1s';
                // DRAG_START.startRightSibling.style.marginLeft = '0px'

                ///////////////////////////////////////////////////////////
                //set game attribute, remove dragging class, set transition
                game.setAttribute('drag-active', false);//FOR CSS TO USE THE RIGHT STYLES
                DRAG_TARGET.classList.remove('dragging'); 
                DRAG_TARGET.style.transition = 'left 1s, top 1s, margin 1s';
                ///////////////////////////////////////////////////////////

                document.removeEventListener('mousemove', onDrag);
                let _activeSlot = game.querySelector('.active-slot') ?? DRAG_START.SLOT;
                const ACTIVE_SLOT = {
                    SLOT: _activeSlot,
                    HOVERED_SIBLING :  _activeSlot ? _activeSlot.querySelector('.draggable:hover:not(.dragging)'): null,
                    LEFT_MOST_SIBLING: _activeSlot ? [..._activeSlot.children][0] : null,
                    RIGHT_MOST_SIBLING: _activeSlot ? [..._activeSlot.children].pop() : null,
                }
                //MOVE TO UTIL TODO
                function isSlotStart(element){return element && element.classList.contains('slot-start');}
                let releaseState = (()=>{ //Immediate Invoke, get releaseState
                    if(!ACTIVE_SLOT.SLOT) return RELEASE_STATE.NONE;
                    if(ACTIVE_SLOT.HOVERED_SIBLING && ACTIVE_SLOT.HOVERED_SIBLING === ACTIVE_SLOT.LEFT_MOST_SIBLING) return RELEASE_STATE.LEFT_MOST;
                    if(ACTIVE_SLOT.HOVERED_SIBLING && ACTIVE_SLOT.HOVERED_SIBLING !== ACTIVE_SLOT.RIGHT_MOST_SIBLING) return RELEASE_STATE.MIDDLE;
                    return RELEASE_STATE.RIGHT_MOST;
                })();//Immediate Invoke ENDS
                let _targetPos = {}; //ENDING POSITION
                switch (releaseState){ //BREAKS TRANSITION , SINCE THEY ARE GETTING BOUNDING BOX IN MID TRANSITION
                    case RELEASE_STATE.NONE:
                        _targetPos = {
                            x: DRAG_START.POS.x, 
                            y: DRAG_START.POS.y, 
                            rightSibling: [...DRAG_START.SLOT.children][DRAG_START.INDEX],
                            leftSibling: [...DRAG_START.SLOT.children][DRAG_START.INDEX-1]
                        };
                    break;
                    case RELEASE_STATE.LEFT_MOST:
                        var targetRect = ACTIVE_SLOT.HOVERED_SIBLING.getBoundingClientRect();
                        _targetPos = {
                            x: targetRect.right + 3,
                            y: ACTIVE_SLOT.SLOT.getBoundingClientRect().top,
                            rightSibling: getNeighborElementsInParent(ACTIVE_SLOT.HOVERED_SIBLING, ACTIVE_SLOT.SLOT).rightNextdoor,
                            leftSibling: ACTIVE_SLOT.HOVERED_SIBLING
                        };
                    break;
                    case RELEASE_STATE.MIDDLE:
                        var targetRect = ACTIVE_SLOT.HOVERED_SIBLING.getBoundingClientRect();
                        _targetPos = {
                            x: targetRect.left + 50,
                            y: ACTIVE_SLOT.SLOT.getBoundingClientRect().top,
                            rightSibling : getNeighborElementsInParent(ACTIVE_SLOT.HOVERED_SIBLING, ACTIVE_SLOT.SLOT).rightNextdoor,
                            leftSibling : ACTIVE_SLOT.HOVERED_SIBLING
                        };
                    break;
                    case RELEASE_STATE.RIGHT_MOST:
                        var targetRect = ACTIVE_SLOT.RIGHT_MOST_SIBLING.getBoundingClientRect();
                        _targetPos = {
                            x: targetRect.left + 50,  
                            y: ACTIVE_SLOT.SLOT.getBoundingClientRect().top,
                            rightSibling : getNeighborElementsInParent(ACTIVE_SLOT.RIGHT_MOST_SIBLING, ACTIVE_SLOT.SLOT).rightNextdoor,
                            leftSibling : ACTIVE_SLOT.RIGHT_MOST_SIBLING
                        };
                    break;
                } const TARGET_POS = _targetPos;
                //TODO: get value from css? apply + or - 50px
                //1s being the standard anim speed
                //OFFSET TARGETPOS.LEFTSIBLING'S MARGIN TO MAKE SPACE FOR CARD
                //TARGET_POS.leftSibling !== ACTIVE_SLOT.HOVERED_SIBLING){//not left most
                if(TARGET_POS.leftSibling && TARGET_POS.leftSibling !== ACTIVE_SLOT.LEFT_MOST_SIBLING){
                    TARGET_POS.leftSibling.marginRight = '-200px';
                }
                //APPLY MARGIN LEFT TO TARGET_POS.rightSibling TO MAKE SPACE FOR CARD
                if(TARGET_POS.rightSibling) TARGET_POS.rightSibling.style.marginLeft = '50px';
                
                //FROM starting GO TO TARGET POSITION
                setTimeout(()=>{ //MOVE TO OFFSET THEN BACK TO 0
                    DRAG_TARGET.style.left =`${TARGET_POS.x}px`; 
                    DRAG_TARGET.style.top = `${TARGET_POS.y}px`;
                },1);
                
                document.removeEventListener('mouseup', releaseDrag);
                //DRAG_TARGET.addEventListener('transitionend', event=>{endTransistion(event)});
                //Using timeout instead of event because event is buggy with spam clicks;
                requestAnimationFrame(()=>{setTimeout(endTransistion, 1000)});
                function endTransistion(){//event = null
                    //if(event.propertyName !== 'left') return;
                    ACTIVE_SLOT.SLOT.insertBefore(DRAG_TARGET, TARGET_POS.rightSibling);
                    DRAG_TARGET.style.position = 'relative';
                    DRAG_TARGET.style.left =`${0}px`; 
                    DRAG_TARGET.style.top = `${0}px`;
                    setTimeout(()=>{game.setAttribute('transitioning', false)},1);
                    //Reset Sibling margins
                    if(TARGET_POS.rightSibling){
                        TARGET_POS.rightSibling.style.transition = 'margin 0s';
                        TARGET_POS.rightSibling.style.marginLeft = '0px';
                        setTimeout(()=>{TARGET_POS.rightSibling.style.transition = 'margin 1s'},1);
                    }
                    if(TARGET_POS.leftSibling){
                        TARGET_POS.leftSibling.style.transition = 'margin 0s';
                        TARGET_POS.leftSibling.style.marginLeft = '0px';
                        setTimeout(()=>{TARGET_POS.leftSibling.style.transition = 'margin 1s'},1);
                    }
                } //END endTransistion
            }//END releaseDrag
        }//END startDrag
    }//END getDraggable
    
    var slots = [];
    function getSlots(){//TODO RENAME, AND SPLIT SETTING LOGIC
        slots = document.querySelectorAll('.slot');
        [...slots].forEach(slot=>{slot.addEventListener('mouseenter', mouseEnter)});
        function mouseEnter(e){
            let curSlot = e.target;
            curSlot.classList.add('active-slot');
            curSlot.addEventListener('mouseleave', mouseleave);
            function mouseleave(e){
                curSlot.classList.remove('active-slot');
            }
        }
    }
    //
    //UTIL
    //
    function getNeighborElementsInParent(selfElement, parentElement){
        let children = [...parentElement.children];
        let selfIndex = children.indexOf(selfElement);
        return {leftNextdoor: children[selfIndex-1], rightNextdoor: children[selfIndex+1]};
    }
    function getRandomFromArr(arr){
        let i = Math.floor(Math.random() * arr.length);
        return arr[i];
    }
</script>
<style>
    :root{/*dark theme*/
        background-color: rgb(42, 42, 42);
        color: azure;
    }
    .suit{/*CONSISTENT EMOJI FONT FOR ALL PLATFORMS?*/
        font-family: "Segoe UI Emoji";
    }
    #game {
        position: relative; /* basis for cards which are outside of #hand */
        /*custom css properties*/
        --card-width : 250px;
        --card-height : 350px;

        --select-card-y-offset : -50px;
        --hand-card-x-offset : -200px;

        --insert-split-distance: -100px;
        --standard-duration: 1s;
        --inner-transform-transition: transform 0.5s;
        --inner-margin-top-transition: margin-top 0.3s;
    }
    #game .hand{
        outline: rgb(189, 255, 8) 3px solid;
        /* display: flex; */
        justify-content: center;
        align-items: center;
        align-content: center;
        align-self: center;

        box-sizing:border-box;
        height: var(--card-height);
        margin-top: 10%;/*HAND AT THE BOTTOM*/
    }
    /* .outer-card{/*DEBUG*/
       /* background-color:rgb(64, 0, 255); */
    /*} */
    #game .outer-card{
        /*CARD SIZE*/
        width: var(--card-width); height: var(--card-height);
        /*TRANSITIONS ARE HANDLED IN JS, THIS IS FOR INITIALIZATION*/
        transition: left 1s, right 1s, margin 1s;
        display: inline-block; /*TEST NEW HAND ALTERNATIVE*/
        white-space: nowrap; /*KEEP CARDS ON THE SAME ROW*/
    }
    /*MOUSE WITHIN HAND, FACE UP FRONT, ELSE FACE UP BACK*/
    /*#game .flippable:active{ /*ON MOUSE DOWN FLIPPING CARD ANIMATION*/
        /*transform: rotateY(180deg) !important; /*FLIPS WHEN CARD IS DRAG OUT OF HAND*/
    /*}*/
    /*#game .dragging .inner-card{ //FLIP USING JS
        transform: rotateY(180deg) !important;
    }*/
    #game .dragging{pointer-events: NONE !important;} /*READ MOUSE EVENT UNDER THE DRAGGABLE*/
    #game[drag-active='true'] .hand .outer-card:hover{/*CARD IN HAND HOVER WHILE DRAG ACTIVE IS TRUE*/
        margin-right: var(--insert-split-distance) !important;/* INSERTION ANIM */
    } 
    #game .hand .outer-card{/*CARD IN HAND, NOT BEING DRAGGED*/
        margin-right: var(--hand-card-x-offset);/*FOR CARD HAND EFFECT*/
    }
    #game .outer-card:hover .inner-card{/*ON MOUSE HOVER, SELECT PULL OUT CARD //:not(:active)*/
        transition: var(--inner-transform-transition), margin-top 0.3s !important;
        margin-top: var(--select-card-y-offset) !important;
    }
    #game .outer-card:active .inner-card{/*ON MOUSE ACTIVE, SELECT PULL OUT CARD //:not(:active)*/
        transition: var(--inner-transform-transition), margin-top 0s;
        margin-top: var(--select-card-y-offset) !important;
    }
    
    #game .inner-card{/*inner*/
        /*ANIMATION*/
        transition: var(--inner-transform-transition), var(--inner-margin-top-transition) !important; /*flips*/
        position: relative;
        transform-style: preserve-3d;
        width: inherit;
        height: inherit;
    }
    .front-face, .back-face{
        width:inherit;
        height:inherit;
        position: absolute;/*MAKES POSITION STAYS IN PLACE*/
        backface-visibility: hidden;
        text-align: center;
        border-radius: 5%;
        perspective: 4000px; /*DETERMINES FORESHORTENING*/
        box-sizing: border-box; /*MAKES BORDER STARTS IN BOX, RATHER OUTSIDE BOX*/
        border-radius: 5%;
        box-shadow:-2px 0px 15px rgba(0, 0, 0, 0.741);
    }
    #game .inner-card>.back-face{/*STYLES FOR CARD BACK*/
        transform: rotateY(180deg);
        border: 15px solid whitesmoke;
        background-color: whitesmoke;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #game .inner-card>.back-face .card-back-display{
        background-color: rgb(34, 48, 118);
        color: whitesmoke;
        height: 100%;
        width: 100%;
        border-radius: 5%;
    }
    #game .inner-card>.front-face{
        background-color: whitesmoke;
        display: grid;
        grid-template-rows: repeat(3, 1fr) repeat(2, 3.5fr) repeat(3, 1fr);
        grid-template-columns: 1fr 4fr 1fr;
        text-align: center;
    }
    #game .inner-card .card-display{
        width: 100%;
        height: 100%;
        grid-row: 2/8;
        grid-column: 2/3;
        /*background-color: rgba(137, 43, 226, 0.201); DEBUG*/
        justify-content: center;
        display: flex;
        flex-direction: row;
        grid-template-rows: repeat(8, 1fr);
        grid-template-columns: repeat(3, 1fr);
    }
    #game .inner-card .card-display .column{/*PARENT OF MIDDLE SUIT*/
        flex: 1; /*keep column size equal*/
        display: flex; /*suits are flex items*/
        flex-direction: column;
        align-items: center;
        justify-content: center; /*PUT CHILD ELEMENT IN VERTICAL CENTER*/
    }
    #game .inner-card .card-display .column .suit{/*DISPLAYED MIDDLE SUITS*/
        position: relative;
        flex : 0 !important;
        display: block;
        margin: auto;
        font-size : 30pt; /*SUIT SIZE*/
    }
    #game .inner-card .card-display .column:not(.MIDDLE) :first-child{
        margin-top: 0%;
    }
    #game .inner-card .card-display .column:not(.MIDDLE) :last-child{
        margin-bottom: 0%;
    }
    #game .inner-card .suit.mid{
        /* outline:rgb(0, 139, 35) 3px solid; */
        width: 100%;
        height: 100%;
    }
    #game .inner-card .suit.top{
        font-size : 20pt;
        transform: rotate(0deg);
        grid-row: 3/4;
        grid-column: 1/2;
    }
    #game .inner-card .suit.bot{
        font-size : 20pt;
        transform: rotateX(180deg);
        grid-row: 5/6;
        grid-column: 3/4;
    }
    #game .inner-card .number{
        width: 100%;
        height: 100%;
        text-align: center;
        letter-spacing:-.15em;
        font-size : 35pt;
        font-weight: bold;
        display: block;
        /* outline:rgb(139, 2, 0) 3px solid;  */
    }
    #game .inner-card .number.top{
        transform: rotate(0deg);
        grid-row: 1/3;
        grid-column: 1/2;
        margin-left:-0.075em;
    }
    #game .inner-card .number.bot{
        transform: rotate(180deg);
        grid-row: 6/8;
        grid-column: 3/4;
        margin-left:0.075em;
    }
    #game .prototype{
        display: NONE !important;
    }
</style>
</html>
