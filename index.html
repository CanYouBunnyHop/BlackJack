<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>♠️♣️CARDS♥️♦️</title>
</head>
    X:<input type="text" id="x">  Y:<input type="text" id="y"> <br>
    mX:<input type="text" id="mx">  mY:<input type="text" id="my"> <br>
    <button type="button" onmousedown="popCardFromDeck()">Hit</button>
    <div id="game" style="user-select: none;">
            <div class="outer-card draggable prototype" lock="false">
                <div class="inner-card flippable">
                    <div class="front-face">
                        <span class="number top">A</span>
                        <span class="suit top"></span>
                        <span class="card-display">
                            <span class="column left"></span>
                            <span class="column middle"></span>
                            <span class="column right"></span>
                        </span><!--end card-display-->
                        <span class="suit bot"></span>
                        <span class="number bot">A</span>
                    </div><!--end front-face-->
                    <div class="back-face">
                        <span class="card-back-display">CARD</span>
                    </div><!--end back-face-->
                </div><!--end inner-card-->
            </div><!--end outer-card-->
        <div class="hand slot" capacity=-1 lock=false id="player-hand">
            <div class="slot-start draggable" lock="true" style=
                "width: 250px;
                height: 350px;
                margin-right: 0px;
                outline: green solid 2px;
                visibility: visible;
                display: inline-block;
                "> <!--for inserting left most card-->
            </div>
        </div>
    </div><!--end #game-->
<script type="text/javascript">
    var game = document.getElementById('game');
    const protoSuit = document.createElement('span');
    protoSuit.classList.add('suit');
    const protoCard = game.querySelector('.outer-card'); //GET THE PROTOTYPE ELEMENT
    const cardData = {
        numbers : ['A','2','3','4','5','6','7','8','9','10','J','Q','K'],
        suits : ['♠️','♣️','♥️','♦️'],
        get randomNumber(){return getRandomFromArr(this.numbers);},
        get randomSuit(){return getRandomFromArr(this.suits);},
    };
    function Card(suit, number){this.suit = suit; this.number = number;}
    function createCard(number = cardData.randomNumber, suit = cardData.randomSuit){
        let clone = protoCard.cloneNode(true);
        clone.classList.remove('prototype');
        clone._number_ = number;
        clone._suit_ = suit;
        clone._cardDisplay_= clone.querySelector('.card-display');
        clone._cardCanvases_=clone.querySelectorAll('.card-canvas'); //FLIP USING CSS
        let leftCol = clone._cardDisplay_.querySelector('.column.left');
        let midCol = clone._cardDisplay_.querySelector('.column.middle');
        let rightCol = clone._cardDisplay_.querySelector('.column.right');
        //CREATE SUIT OBJECT BASE ON NUMBERS HERE
        let appendSuits=(l,m,r)=>{//ADD SUIT TO COLUMNS
            for(let i=0; i<l; i++){leftCol.appendChild(protoSuit.cloneNode());}
            for(let i=0; i<m; i++){midCol.appendChild(protoSuit.cloneNode());}
            for(let i=0; i<r; i++){rightCol.appendChild(protoSuit.cloneNode());}
            rotateBotSuits();
        }
        let rotateBotSuits=()=>{
            [leftCol, midCol, rightCol].forEach(innerArr=>{
                let botHalfCount = Math.floor(innerArr.children.length/2);
                let slicePos = innerArr.children.length - botHalfCount;
                let botHalf = [...innerArr.children].slice(slicePos);
                [...botHalf].forEach(suit=>{suit.style.transform = 'rotate(180deg)'});
            });
        }
        let hideSuit=(col, index)=>{
            col.children[index].style.visibility ='hidden';
        }
        switch (clone._number_){
            case 'A':appendSuits(0,1,0);break;
            case '2':appendSuits(0,2,0);break;
            case '3':appendSuits(0,3,0);break;
            case '4':appendSuits(2,0,2);break;
            case '5':appendSuits(2,1,2);break;
            case '6':appendSuits(3,0,3);break;
            case '7':appendSuits(3,2,3); hideSuit(midCol, 1); break;
            case '8':appendSuits(3,2,3);break;
            case '9':appendSuits(4,1,4);break;
            case '10':appendSuits(4,2,4);break;
            case 'J': case 'Q': case 'K':
                appendSuits(2,0,2);
                hideSuit(leftCol, 1);
                hideSuit(rightCol, 0);
                break;
        }
        [...clone.querySelectorAll('.number')].forEach(element=>{element.innerHTML = number;});
        [...clone.querySelectorAll('.suit')].forEach(element=>{element.innerHTML = suit;});
        clone.style.color = ['♥️','♦️'].includes(clone._suit_) ? 'crimson' : 'black';
        return clone;
    }
    function popCardFromDeck(){//TEST
        //testing for now
       let newCard = createCard();
       game.appendChild(newCard);
       newCard.style.left = '1400px';
       newCard.style.top = '0px';
       newCard.style.position='fixed';
       newCard.style.transition='left 1s, top 1s, margin 1s';
       //GETTING OFFSET HERE
       var hand = document.getElementById('player-hand');
       var lastChildRect = [...hand.children].pop().getBoundingClientRect();
       var xOffset = lastChildRect.right - 200; //MAGIC NUMBER FROM CSS
       var yOffset = lastChildRect.top;

       setTimeout(()=>{
        newCard.style.left = `${xOffset}px`;
        newCard.style.top = `${yOffset}px`;
       },1);

       requestAnimationFrame(()=>{//use transistion end instead
            setTimeout(()=>{
                console.log('frame called');
                hand.appendChild(newCard)
                newCard.style.left = `${0}px`;
                newCard.style.top = `${0}px`;
                newCard.style.position='relative';
            },1000);
       })
    }
    //WHEN PAGE FINISH LOADING //PROBABLY WANT TO USE DEFERED ON THE SCRIPT INSTEAD
    window.onload = function(){
       for(let i =0; i<5; i++){
             let hand = game.querySelector('.hand');//TEST
             hand.appendChild(createCard()); //TEST
            //game.appendChild(createCard());
       }
        //game.appendChild(createCard());
       getDraggables();
       getSlots();
    };
    //
    //CARD DRAGGABLE LOGIC
    //
    //TODO: CLEAN UP CODE
    //startRightSibling and hoverRightSibling can be one
    //repitition in end transition
    //fix bug where startRightSibling margin is called when appending to right most
    //use enum state
    var draggables = [];
    function getDraggables(){//TODO RENAME, AND SPLIT SETTING LOGIC
        draggables = document.querySelectorAll('.draggable');
        [...draggables].forEach(element=>{element.addEventListener('mousedown', startDrag)});
        let dragStart = {mousePos: {x:0, y:0}, pos: {x:0, y:0}};

        function startDrag(e){ //MOUSE DOWN EVENT
            let dragTarget = e.target.closest('.draggable');
            if(dragTarget.getAttribute('lock') === "true") return; //IF LOCKED RETURN
            if(game.getAttribute('transitioning') === "true") return;

            ///////////////////////////////////////////////////////////
            //set game attribute, remove dragging class, set transition
            game.setAttribute('drag-active', true); //FOR CSS TO USE THE RIGHT STYLES
            dragTarget.classList.add('dragging'); //ADD DRAGGING CLASS FOR EASY ACCESS ELSE WHERE
            dragTarget.style.transition = 'top 0s, left 0s, margin 1s';
            ///////////////////////////////////////////////////////////

            let rect = dragTarget.getBoundingClientRect();
            //
            //DEBUG
            document.getElementById('x').value = rect.left;
            document.getElementById('y').value = rect.top;
            //END DEBUG
            //
            
            dragStart = {
                mousePos: {x: e.clientX, y: e.clientY},
                pos: {x: dragTarget.getBoundingClientRect().x, y: dragTarget.getBoundingClientRect().y}
            }
            dragTarget.style.position = 'fixed';
            //REMEMBER ORIGIN POS AND CHILD INDEX
            let startSlot = e.target.closest('.slot');
            let dragStartIndex = [...startSlot.children].indexOf(dragTarget); //FIND THE INDEX OF SELECTED DRAGGABLE
            let startRightSibling = getNeighborElementsInParent(dragTarget, startSlot).rightNextdoor;
            function onDrag(event){
                let dragDist = {x: event.clientX- dragStart.mousePos.x, y: event.clientY - dragStart.mousePos.y}
                let targetPosY = `${dragStart.pos.y + dragDist.y}px` //-50 is from select animation
                let targetPosX = `${dragStart.pos.x + dragDist.x}px`
                dragTarget.style.top = targetPosY;
                dragTarget.style.left = targetPosX;
                if(targetPosX !== dragStart.pos.x || targetPosY !== dragStart.pos.y)
                game.setAttribute('transitioning', true);
            } onDrag(e);
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', releaseDrag);
            game.appendChild(dragTarget);  //REMOVES FROM PARENT DIV TO GAME //NEVER UNAPPEND?
            function releaseDrag(event){
                const RELEASE_STATE = {leftMost: 0, middle: 1, rightMost: 2, none: 3};
                let activeSlot = game.querySelector('.active-slot');

                ///////////////////////////////////////////////////////////
                //set game attribute, remove dragging class, set transition
                game.setAttribute('drag-active', false);//FOR CSS TO USE THE RIGHT STYLES
                dragTarget.classList.remove('dragging'); 
                dragTarget.style.transition = 'margin 1s, top 1s, left 1s';
                ///////////////////////////////////////////////////////////

                document.removeEventListener('mousemove', onDrag);
                let hoverSibling = activeSlot ? activeSlot.querySelector('.draggable:hover:not(.dragging)'): null;
                //let hoverRightSibling = activeSlot ? getNeighborElementsInParent(hoverSibling, activeSlot).rightNextdoor : null;
                let leftMostSibling = activeSlot ? [...activeSlot.children][0] : null;
                let rightMostSibling = activeSlot ? [...activeSlot.children].pop() : null;
                
                //MOVE TO UTIL TODO
                function isSlotStart(element){return element && element.classList.contains('slot-start');}
                let getReleaseState = (()=>{ //IMMEDIATE INVOKE
                    if(!activeSlot) return RELEASE_STATE.none;
                    if(hoverSibling && hoverSibling === leftMostSibling) return RELEASE_STATE.leftMost;
                    if(hoverSibling && hoverSibling !== rightMostSibling) return RELEASE_STATE.middle;
                    return RELEASE_STATE.rightMost;
                })();//IMMEDIATE INVOKE ENDS
                let startSibling;
                let targetPos;
                switch(getReleaseState){
                    case RELEASE_STATE.none: //use original
                        targetPos = {
                            x: dragStart.pos.x, 
                            y: dragStart.pos.y, 
                            rightSibling: [...startSlot.children][dragStartIndex],
                            leftSibling: [...startSlot.children][dragStartIndex]
                        };
                    break;
                    case RELEASE_STATE.leftMost:
                        var targetRect = leftMostSibling.getBoundingClientRect();
                        targetPos = {
                            x: targetRect.right + 3,
                            y: activeSlot.getBoundingClientRect().top,
                            rightSibling: getNeighborElementsInParent(leftMostSibling, activeSlot).rightNextdoor,
                            leftSibling: leftMostSibling
                        };
                    break;
                    case RELEASE_STATE.middle:
                        var targetRect = hoverSibling.getBoundingClientRect();
                        targetPos = {
                            x: targetRect.left + 50,
                            y: activeSlot.getBoundingClientRect().top,
                            rightSibling : getNeighborElementsInParent(hoverSibling, activeSlot).rightNextdoor,
                            leftSibling : hoverSibling
                        };
                    break;
                    case RELEASE_STATE.rightMost:
                        var targetRect = rightMostSibling.getBoundingClientRect();
                        targetPos = {
                            x: targetRect.left + 50,
                            y: activeSlot.getBoundingClientRect().top,
                            rightSibling : getNeighborElementsInParent(rightMostSibling, activeSlot).rightNextdoor,
                            leftSibling : rightMostSibling
                        }
                    break;
                }
                console.log(getReleaseState);
                //TODO: get value from css? apply + or - 50px
                //1s being the standard anim speed
                //OFFSET TARGETPOS.LEFTSIBLING'S MARGIN TO MAKE SPACE FOR CARD
                // if(targetPos.leftSibling && targetPos.leftSibling !== leftMostSibling){//targetPos.leftSibling !== leftMostSibling){//not left most
                //     targetPos.leftSibling.marginRight = '-200px';
                // }else{//is left most
                //     targetPos.leftSibling.style.transition = 'margin 1s';
                //     targetPos.leftSibling.style.marginRight = '0px';
                // }
                // //APPLY MARGIN LEFT TO targetPos.rightSibling TO MAKE SPACE FOR CARD
                // if(targetPos.rightSibling) targetPos.rightSibling.style.marginLeft = '50px';
                //GO TO TARGET POSITION
                console.log('MOVE', {x:targetPos.x, y:targetPos.y});
                dragTarget.style.left =`${targetPos.x}px`;
                dragTarget.style.top = `${targetPos.y}px`;
                //USE TIMER INSTEAD OF EVENT
                //setTimeout(endTransistion, 4000);
                dragTarget.addEventListener('transitionend', endTransistion);
              

                //CALCULATE TARGET POSITION, ALSO RETURNS THE RIGHT SIBLING TO BE APPEND BEFORE
                // let targetPoss = (()=>{//IMMEDIATE EXECUTION
                //     //THE NEW SIBLING WHO MOVES INTO THE ORIGINAL INDEX
                //     let startSibling = [...startSlot.children][dragStartIndex];
                //     let resultPos = {...dragStart.pos, sibling: startSibling};//INITIAL USE ORIGINAL POSIITION
                //     let rightSibling = startSibling;
                //     //IF CARD IS WITHIN SLOT BOUNDARIES AND HOVER ON A CHILD
                //     if(hoverSibling){
                //         rightSibling = getNeighborElementsInParent(hoverSibling, activeSlot).rightNextdoor;
                //         let targetRect = hoverSibling.getBoundingClientRect();//ELEMENT HOVERED ON IN SLOT
                //         //MAGIC NUMBER 250px - 200px
                //         //250 is cards width //-200 is cards margin right
                //         //+3 is because for some reason it's not alligned perfectly
                //         resultPos.x  = !isHoveringSlotStart? targetRect.left + 50 : targetRect.right + 3;
                //         //MAGIC NUMBER, //-100 is margin-right insert-animation //RETHINK
                //         // cardWidth - cardMarginRight = cardSpaceTaken // 250px - 200px = 50px
                //         // hoverSibling.marginRight += cardSpaceTaken  // -200px + 50px = -150px
                    
                    //TO OFFSET SIBLING'S MARGIN TO MAKE SPACE FOR CARD
                    // if(isHoveringSlotStart){//IS SLOT START
                    //     hoverSibling.style.transition = 'margin 1s'; 
                    //     hoverSibling.style.marginRight = '50px';
                    // }else{//IS NOT SLOT START
                    //     hoverSibling.style.marginRight = '-200px';
                    // }


                    //if targetPos.rightSibling
                    //if(hoverRightSibling) hoverRightSibling.style.marginLeft = '50px';

                    // }else if(activeSlot){//IF IS HOVERING WITHIN SLOT, BUT NO CHILD
                    //     let lastChild = [...activeSlot.children].pop();
                    //     rightSibling = getNeighborElementsInParent(lastChild, activeSlot).rightNextdoor;
                    //     let targetRect = lastChild.getBoundingClientRect(); //LAST CHILD IN SLOT
                    //     //MAGIC NUMBER 250px - 200px
                    //     //250 is cards width //-200 is cards margin
                    //     resultPos.x  = !isSlotStart(lastChild)? targetRect.left + 50 : targetRect.right + 3;
                    // }
                    
                   
                    
                    // APPLY MARGIN LEFT TO START RIGHT SIBLING
                    // if(startRightSibling) startRightSibling.style.marginLeft = '50px'

                    
                    // if(activeSlot) resultPos.y = activeSlot.getBoundingClientRect().top;  
                    // resultPos.sibling = rightSibling;
                    // return resultPos;

                //})(); //IMMEDIATE EXECUTION ENDS
                
                function endTransistion(){
                    //if(event.propertyName !== 'left') return;
                    if(targetPos.rightSibling){
                        targetPos.rightSibling.style.transition = 'margin 0s';
                        targetPos.rightSibling.style.marginLeft = '0px';
                        setTimeout(()=>{
                            targetPos.rightSibling.style.transition = 'margin 1s';
                        },1);
                    }
                    if(targetPos.leftSibling){
                        targetPos.leftSibling.style.transition = 'margin 0s';
                        targetPos.leftSibling.style.marginLeft = '0px';
                        setTimeout(()=>{
                            targetPos.leftSibling.style.transition = 'margin 1s';
                        },1);
                    }

                    // if(startRightSibling){ //IF targetPos.rightSibling
                    //     startRightSibling.style.transition = 'margin 0s';
                    //     startRightSibling.style.marginLeft = '0px';
                    //     setTimeout(()=>{
                    //         startRightSibling.style.transition = 'margin 1s';
                    //     },1);
                    // }
                    // if(hoverRightSibling){ //SAME THING AS ABOVE
                    //     hoverRightSibling.style.transition = 'margin 0s';
                    //     hoverRightSibling.style.marginLeft = '0px';
                    //     setTimeout(()=>{
                    //         hoverRightSibling.style.transition = 'margin 1s';
                    //     },1);
                    // }
                    // if(isHoveringSlotStart){//SAME THING AS ABOVE //IS SLOT START
                    //     hoverSibling.style.transition = 'margin 0s';
                    //     hoverSibling.style.marginRight = '0px';
                    //     setTimeout(()=>{
                    //         hoverSibling.style.transition = 'margin 1s';
                    //     },1);
                    // }
                    //
                    //  //  I FORGOT WHAT THIS DOES 
                    //
                    // else if(!isHoveringSlotStart && hoverSibling){//NOT SLOT START
                    //     //RESET MARGIN HANED EFFECT IN INSTANT
                    //     hoverSibling.style.transition = 'margin 0s, top 1s, left 1s, ';
                    //     hoverSibling.style.marginRight = '-200px';
                    //     setTimeout(()=>{
                    //         hoverSibling.style.transition = 'margin 1s, top 1s, left 1s';
                    //     },1);
                    }
                    document.removeEventListener('mouseup', releaseDrag);
                    dragTarget.style.top = `${0}px`; 
                    dragTarget.style.left =`${0}px`;
                    console.log('APPEND');
                    startSlot.insertBefore(dragTarget, targetPos.rightSibling); //seems to work with last sibling
                    dragTarget.style.position = 'relative';
                    game.setAttribute('transitioning', false);
                }
            }
        }
    var slots = [];
    function getSlots(){//TODO RENAME, AND SPLIT SETTING LOGIC
        slots = document.querySelectorAll('.slot');
        [...slots].forEach(slot=>{slot.addEventListener('mouseenter', mouseEnter)});
        function mouseEnter(e){
            let curSlot = e.target;
            curSlot.classList.add('active-slot');
            curSlot.addEventListener('mouseleave', mouseleave);
            function mouseleave(e){
                curSlot.classList.remove('active-slot');
            }
        }
    }
    //
    //UTIL
    //
    function getNeighborElementsInParent(selfElement, parentElement){
        let children = [...parentElement.children];
        let selfIndex = children.indexOf(selfElement);
        return {leftNextdoor: children[selfIndex-1], rightNextdoor: children[selfIndex+1]};
    }
    function getRandomFromArr(arr){
        let i = Math.floor(Math.random() * arr.length);
        return arr[i];
    }
</script>
<style>
    :root{/*dark theme*/
        background-color: rgb(42, 42, 42);
        color: azure;
    }
    .suit{/*CONSISTENT EMOJI FONT FOR ALL PLATFORMS?*/
        font-family: "Segoe UI Emoji";
    }
    #game {
        position: relative; /* basis for cards which are outside of #hand */
        /*custom css properties*/
        --card-width : 250px;
        --card-height : 350px;

        --select-card-y-offset : -50px;
        --hand-card-x-offset : -200px;

        --insert-split-distance: -100px;
        --standard-duration: 1s;
        --inner-transform-transition: transform 0.5s;
        --inner-margin-top-transition: margin-top 0.3s;
    }
    #game .hand{
        outline: rgb(189, 255, 8) 3px solid;
        /* display: flex; */
        justify-content: center;
        align-items: center;
        align-content: center;
        align-self: center;

        box-sizing:border-box;
        height: var(--card-height);
        margin-top: 10%;/*HAND AT THE BOTTOM*/
    }
    /* .outer-card{/*DEBUG*/
       /* background-color:rgb(64, 0, 255); */
    /*} */
    #game .outer-card{
        /*CARD SIZE*/
        width: var(--card-width); height: var(--card-height);
        transition: left 1s, right 1s, margin 1s;
        display: inline-block; /*TEST NEW HAND ALTERNATIVE*/
        white-space: nowrap; /*KEEP CARDS ON THE SAME ROW*/
    }
    /*MOUSE WITHIN HAND, FACE UP FRONT, ELSE FACE UP BACK*/
    /*#game .flippable:active{ /*ON MOUSE DOWN FLIPPING CARD ANIMATION*/
        /*transform: rotateY(180deg) !important; /*FLIPS WHEN CARD IS DRAG OUT OF HAND*/
    /*}*/
    /*#game .dragging .inner-card{ //FLIP USING JS
        transform: rotateY(180deg) !important;
    }*/
    #game .dragging{pointer-events: none !important;} /*READ MOUSE EVENT UNDER THE DRAGGABLE*/
    #game[drag-active='true'] .hand .outer-card:hover{/*CARD IN HAND HOVER WHILE DRAG ACTIVE IS TRUE*/
        margin-right: var(--insert-split-distance) !important;/* INSERTION ANIM */
    } 
    #game .hand .outer-card{/*CARD IN HAND, NOT BEING DRAGGED*/
        margin-right: var(--hand-card-x-offset);/*FOR CARD HAND EFFECT*/
        /*TRANSITIONS ARE HANDLED IN JS*/
    }
    #game .outer-card:hover .inner-card{/*ON MOUSE HOVER, SELECT PULL OUT CARD //:not(:active)*/
        transition: var(--inner-transform-transition), margin-top 0.3s !important;
        margin-top: var(--select-card-y-offset) !important;
    }
    #game .outer-card:active .inner-card{/*ON MOUSE ACTIVE, SELECT PULL OUT CARD //:not(:active)*/
        transition: var(--inner-transform-transition), margin-top 0s;
        margin-top: var(--select-card-y-offset) !important;
    }
    
    #game .inner-card{/*inner*/
        /*ANIMATION*/
        transition: var(--inner-transform-transition), var(--inner-margin-top-transition) !important; /*flips*/
        position: relative;
        transform-style: preserve-3d;
        width: inherit;
        height: inherit;
    }
    .front-face, .back-face{
        width:inherit;
        height:inherit;
        position: absolute;/*MAKES POSITION STAYS IN PLACE*/
        backface-visibility: hidden;
        text-align: center;
        border-radius: 5%;
        perspective: 4000px; /*DETERMINES FORESHORTENING*/
        box-sizing: border-box; /*MAKES BORDER STARTS IN BOX, RATHER OUTSIDE BOX*/
        border-radius: 5%;
        box-shadow:-2px 0px 15px rgba(0, 0, 0, 0.741);
    }
    #game .inner-card>.back-face{/*STYLES FOR CARD BACK*/
        transform: rotateY(180deg);
        border: 15px solid whitesmoke;
        background-color: whitesmoke;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #game .inner-card>.back-face .card-back-display{
        background-color: rgb(34, 48, 118);
        color: whitesmoke;
        height: 100%;
        width: 100%;
        border-radius: 5%;
    }
    #game .inner-card>.front-face{
        background-color: whitesmoke;
        display: grid;
        grid-template-rows: repeat(3, 1fr) repeat(2, 3.5fr) repeat(3, 1fr);
        grid-template-columns: 1fr 4fr 1fr;
        text-align: center;
    }
    #game .inner-card .card-display{
        width: 100%;
        height: 100%;
        grid-row: 2/8;
        grid-column: 2/3;
        /*background-color: rgba(137, 43, 226, 0.201); DEBUG*/
        justify-content: center;
        display: flex;
        flex-direction: row;
        grid-template-rows: repeat(8, 1fr);
        grid-template-columns: repeat(3, 1fr);
    }
    #game .inner-card .card-display .column{/*PARENT OF MIDDLE SUIT*/
        flex: 1; /*keep column size equal*/
        display: flex; /*suits are flex items*/
        flex-direction: column;
        align-items: center;
        justify-content: center; /*PUT CHILD ELEMENT IN VERTICAL CENTER*/
    }
    #game .inner-card .card-display .column .suit{/*DISPLAYED MIDDLE SUITS*/
        position: relative;
        flex : 0 !important;
        display: block;
        margin: auto;
        font-size : 30pt; /*SUIT SIZE*/
    }
    #game .inner-card .card-display .column:not(.middle) :first-child{
        margin-top: 0%;
    }
    #game .inner-card .card-display .column:not(.middle) :last-child{
        margin-bottom: 0%;
    }
    #game .inner-card .suit.mid{
        /* outline:rgb(0, 139, 35) 3px solid; */
        width: 100%;
        height: 100%;
    }
    #game .inner-card .suit.top{
        font-size : 20pt;
        transform: rotate(0deg);
        grid-row: 3/4;
        grid-column: 1/2;
    }
    #game .inner-card .suit.bot{
        font-size : 20pt;
        transform: rotateX(180deg);
        grid-row: 5/6;
        grid-column: 3/4;
    }
    #game .inner-card .number{
        width: 100%;
        height: 100%;
        text-align: center;
        letter-spacing:-.15em;
        font-size : 35pt;
        font-weight: bold;
        display: block;
        /* outline:rgb(139, 2, 0) 3px solid;  */
    }
    #game .inner-card .number.top{
        transform: rotate(0deg);
        grid-row: 1/3;
        grid-column: 1/2;
        margin-left:-0.075em;
    }
    #game .inner-card .number.bot{
        transform: rotate(180deg);
        grid-row: 6/8;
        grid-column: 3/4;
        margin-left:0.075em;
    }
    #game .prototype{
        display: none !important;
    }
</style>
</html>
